
// Artin Symbol
intrinsic ArtinSymbol(ZK::RngOrd, pp::RngOrdIdl) -> RngIntElt
{.}
    vprintf HilbertModularForms,1: "%o,%o,%o", ZK, pp, BaseRing(ZK);
    if not IsPrime(pp) then
	fac := Factorization(pp);
	return &*([1] cat [ArtinSymbol(fac, p[1]) : p in fac | IsOdd(p[2])]);
    end if;
    if IsSplit(pp,ZK) then return 1;
    elif IsRamified(pp,ZK) then return 0;
    else return -1; end if;
end intrinsic;

function LocalOptimalEmbeddingNumbers(b1, a1, prime, exponent)
    // Compute the number of local embeddings of the monogenic order
    // x^2 + b1 * x + a1.
    return EmbeddingNumbers(b1, a1, prime, exponent);
end function;

function ClassNumberOfOrderWithConductor(ZK, bb)
    // Class number of the order with conductor bb.
    factsbb := Factorization(bb);
    artinFactors := [1 - ArtinSymbol(ZK, pp[1]) * Norm(pp[1])^(-1) : pp in factsbb];
    term := IsEmpty(factsbb) select Norm(bb) else Norm(bb) * (&* artinFactors);

    // print ClassNumber(AbsoluteOrder(ZK));
    return ClassNumber(AbsoluteOrder(ZK)) * term;
end function;

function NumberOfAdelicOptimalEmbeddings(ZF, level, pair)
    // Preliminaries
    b := pair[1];
    a := pair[2];
    D := b^2-4*a;
    F := NumberField(ZF);
    // _<x> := PolynomialRing(F);
    // K := ext<F | x^2 - D >; 
    // ZK := Integers(K); 
    // DD := Discriminant(ZK); 

    //ff := Sqrt((D*ZF)/DD); // Conductor   
    //Kabs := AbsoluteField(K);
    //ZKabs := Integers(Kabs);
    //UK,mUK := UnitGroup(ZKabs);
    //_, mKabstoK := IsIsomorphic(Kabs,K);
    
    term := 1;
    for pp in Factorization(level) do  
        term *:= LocalOptimalEmbeddingNumbers(pair[1], pair[2], pp[1], pp[2]);
    end for;
    return term;
end function;

function PicardNumberOfMonogenicOrder(ZF, pair)
    // Compute the Picard number of the order ZF[x]/<x^2 + ax + b>, where [a,b] = pair.

    // Preliminaries
    b := pair[1];
    a := pair[2];
    D := b^2-4*a;
    F := NumberField(ZF);
    _<x> := PolynomialRing(F);
    K := ext<F | x^2 - D >; 
    ZK := Integers(K); 
    DD := Discriminant(ZK); 
    ff := Sqrt((D*ZF)/DD); // Conductor   
    Kabs := AbsoluteField(K);
    ZKabs := Integers(Kabs);
    UK,mUK := UnitGroup(ZKabs);
    _, mKabstoK := IsIsomorphic(Kabs,K);

    if false then
        print "Pair:", pair;
        print "Discriminant", D, Discriminant(Kabs), ClassNumber(Kabs);
        print "Conductor", ff;
        print "Class number of order", ClassNumberOfOrderWithConductor(ZK, ff);
    end if;
        
    // This is the fudge factor for converting from adelic to the thing we want.
    // 1a. Compute h = Class number
    h := ClassNumber(Kabs); 
    
    return ClassNumberOfOrderWithConductor(ZK, ff);
end function;

function PossibleIsotropyOrders(F)
    // Create the Graded ring.
    M := GradedRingOfHMFs(F, 1);

    // Possible characteristic polynomials for elliptic automorphisms.
    possibleCharPolys := IndexOfSummation(M, 1*Integers(F), 1*Integers(F));
    vprintf HilbertModularForms,1: "%o", possibleCharPolys;

    // The order ZF[zetaq] has two associated cyclotomic polynomials. Thus, we
    // need to fix one choice of these.

    ret := [];
    for poly in possibleCharPolys do
        if not [-poly[1], poly[2]] in ret then
            Append(~ret, poly);
        end if;
    end for;
    return ret;
end function;


intrinsic CountEllipticPoints(Gamma::StupidCongruenceSubgroup :  prec:=5) -> Any
{Given a congruence subgroup `Gamma` (level, field, decoration data), return
}
    // The algorithm is based on page 739 of "Quaternion Algebra, Voight".
    // Essentially, we count optimal embeddings of the order generated by the
    // isotropy group of the elliptic point into Gamma, up to conjugation.
    //
    // In the notation of JV, the number of embeddings of S into O, up to conjugation
    // by Gamma is m(S, O; Gamma).

    // First find all the S's.

    F := Field(Gamma);
    ZF := MaximalOrder(F);
    hFplus := NarrowClassNumber(F);
    dim := Degree(F); // Dimension of Hilbert modular variety.
    assert dim eq 2;
    
    UF, mUF := UnitGroup(F);
    level := Level(Gamma);
    aa := 1*MaximalOrder(F);

    possibleMonogenicOrders := PossibleIsotropyOrders(F);
    
    // Create the associated S's, then adding up their contribution.

    // 1. First compute the number of embeddings m(hatS, hatO; hatOx) adelically.
    Sumterm := 0;
    _<x> := PolynomialRing(F);

    // The forumla in Proposition 4.2.3 says that the number of elliptic points
    // is
    //
    //     mq^+ = 2^(n-1)/h^+(R) * Sum(S; h(S) * m(hatS, hatO; hatOtimes).
    //
    // We loop over the terms S (valid monogenic orders that could be isotropy orders).

    ellipticCounts := AssociativeArray();
    for pair in possibleMonogenicOrders do // NOTE: Divides things up wrong.
        hS := PicardNumberOfMonogenicOrder(ZF, pair);
        localCount := NumberOfAdelicOptimalEmbeddings(ZF, level, pair);

        vprintf HilbertModularForms,1: "%o,%o", localCount, hS;
        
        // This particular term depends on the particular group of interest.
        if true then
            // The case of van der Geer -- PGL_2^+ acting on upper-half-plane-squared HH^2.
            groupCorrectionFactor := 2^(dim-1);
        elif false then
            // The case of SL.
            // TODO: Add in the unit index term.
        end if;

        // Record the data into the table.
        a, b := Explode(pair);
        ellipticCounts[<a, b>] := (hS/hFplus) * groupCorrectionFactor * localCount;        
    end for;
        
    return ellipticCounts;
end intrinsic;

/*
    // 1b. Unit index w = 2 * [ZK : ZF]
    w := 2 * #quo< UK | [ (mKabstoK(mUF(u))) @@ mUK : u in Generators(UF) ] >; 

    print "Unit index", w;
    w := 1;
    
    // Class number over unit index.
    C := h/w;

    // Conductor Sum
    // Instead of computing all embedding for S, instead we loop over all optimal orders
    // ff <= O <= MaximalOrder(K), where K is the imaginary quadratic field and ff is the
    // conductor of S/F, (where S is the quadratic order associated to the isotropy group).
    conductorsum := 0;

    // Determine the adelic optimal embeddings.
    // TODO: XXX: This is missing a term.
    term := ClassNumberOfOrderWithConductor(ZK, ff); // TODO: Missing term.
    term *:= 
    conductorsum +:= term;

    // Add to Sumterm


    /*
    for bb in Divisors(ff) do    
        // term from converting class number of order to class number of maximal order
        term := ClassNumberOfOrderWithConductor(ZK, bb);


        // Embedding numbers
        adelicOEN := 1;
        for pp in Factorization(mm) do
            adelicOEN *:= LocalOptimalEmbeddingNumbers(b,a,pp[1],pp[2]);
        end for;


        for pp in Factorization(mm) do  
            // Create a polynomial (aka, a monogenic order) x^2 + b1x + a1 with conductor bb.

            b0, a0 := PolynomialMaximalOrder(b,a,ZF,pp[1]);
            pi := UniformizingElement(pp[1]);
            vbb := Valuation(bb,pp[1]);
            b1 := b0 * pi^(vbb);
            a1 := a0 * pi^(2 * vbb); // The polynomial encoded as (b1, a1);
            term *:= LocalOptimalEmbeddingNumbers(b1,a1,pp[1],pp[2]);
        end for;
        print term, C;
        conductorsum +:= term;
    end for;

*/        

