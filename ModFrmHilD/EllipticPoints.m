////////////////////////////////////////////////////////////////////////////////
//
//     EllipticPoints.m
//
// Functionality for computing the number and types of elliptic points.
//
////////////////////////////////////////////////////////////////////////////////

// Types, Records, and Constants.
OrderTermRecordFormat := recformat<Order, Conductor, PicardNumber, HasseUnitIndex>;


////////////////////////////////////////////////////////////////////////////////
//
// Helper functions.
//
////////////////////////////////////////////////////////////////////////////////

intrinsic TotallyPositiveUnitsModSquaresRepresentatives(UF, mUF) -> Any
{}
    // UF  -- Unit group of ground field F.
    // mUF -- The map.

    Ugens := Setseq(Generators(UF));
    TotallyPositiveUnits := [];
    for v in CartesianPower([0,1], #Ugens) do
        unitelt := mUF(&*[Ugens[i] * v[i] : i in [1..#Ugens]]);
        if IsTotallyPositive(unitelt) then
            Append(~TotallyPositiveUnits, unitelt);
        end if;
    end for;
    return TotallyPositiveUnits;
end intrinsic;

// Artin Symbol
intrinsic ArtinSymbol(ZK::RngOrd, pp::RngOrdIdl) -> RngIntElt
{.}
    vprintf HilbertModularForms,1: "%o,%o,%o", ZK, pp, BaseRing(ZK);
    if not IsPrime(pp) then
	fac := Factorization(pp);
	return &*([1] cat [ArtinSymbol(fac, p[1]) : p in fac | IsOdd(p[2])]);
    end if;
    if IsSplit(pp,ZK) then return 1;
    elif IsRamified(pp,ZK) then return 0;
    else return -1; end if;
end intrinsic;


function LocalOptimalEmbeddingNumbers(b1, a1, prime, exponent)
    // Compute the number of local embeddings of the monogenic order
    // x^2 + b1 * x + a1.
    return EmbeddingNumbers(b1, a1, prime, exponent);
end function;


function OrderWithConductor(ZK, ff)
    // Given ff, return an order in ZK whose conductor is ff.
    K  := NumberField(ZK);
    noIdeaWhatThis := Generators(PseudoBasis(Module(ZK))[2][1]);

    Oq := sub<ZK | [K ! g * zki * ZK.2 : g in Generators(ff), zki in noIdeaWhatThis]>;
    return Oq;
end function;


function NumberOfAdelicOptimalEmbeddings(ZF, level, pair)
    // Preliminaries
    b := pair[1];
    a := pair[2];
    D := b^2-4*a;
    F := NumberField(ZF);
    // _<x> := PolynomialRing(F);
    // K := ext<F | x^2 - D >; 
    // ZK := Integers(K); 
    // DD := Discriminant(ZK); 

    //ff := Sqrt((D*ZF)/DD); // Conductor   
    //Kabs := AbsoluteField(K);
    //ZKabs := Integers(Kabs);
    //UK,mUK := UnitGroup(ZKabs);
    //_, mKabstoK := IsIsomorphic(Kabs,K);
    
    term := 1;
    for pp in Factorization(level) do  
        term *:= LocalOptimalEmbeddingNumbers(pair[1], pair[2], pp[1], pp[2]);
    end for;
    return term;
end function;

intrinsic OrdersContaining(ZK, S) -> Any
{Given an order S contained in the maximal order ZK for a number field K, 
compute all orders in K containing S.
It is assumed that S is generated by ZK.1 .}

    ZF := BaseRing(ZK);
    K  := NumberField(ZK);
    assert ZK.1 eq ZK ! S.1; // Sanity check.
    
    Dq := Discriminant(MinimalPolynomial(K.1));
    ff := SquareRoot(ZF !! Discriminant(S)/Discriminant(ZK));
    
    UK, mUK := UnitGroup(AbsoluteOrder(ZK));
    wK := #TorsionSubgroup(UK);

    // Loop over orders by their conductor dff.
    orders := [];
    conductors := [];
    for dff in Divisors(ff) do
        Append(~orders, OrderWithConductor(ZK, dff));
        Append(~conductors, dff);
    end for;

    return orders, conductors;
end intrinsic;


intrinsic OrderTermData(F::FldNum, Group::MonStgElt, rho::RngIntElt : Bound:=0) -> Rec
{Given a real quadratic field F, and some other parameter `rho`, returns the orders associated
to rho along with cached data needed to evaluate important quantities. The data is returned
as a record.}    
    // We want the automorphism of order 2q.
    assert IsEven(rho) and rho ne 2;

    if Group eq "GL+" and rho eq 4 then   // Special case of the formula.
        UF, mUF := UnitGroup(MaximalOrder(F));
        tpunits := TotallyPositiveUnitsModSquaresRepresentatives(UF, mUF);

        _<T> := PolynomialRing(F);        
        fieldList := [ext<F | T^2 + u> : u in tpunits];
    else
        fs := Factorization(CyclotomicPolynomial(rho), F)[1][1];
        fieldList := [ext<F | fs>];
    end if;
        
    return &cat[OrderTermDataForK(K : Bound:=Bound) : K in fieldList];
end intrinsic;

    
intrinsic OrderTermDataForK(K::FldNum : Bound := 0) -> Rec
{Given a quadratic extension K of a totally real field F, where K.1 corresponds to the
relevant generator of the order, compute all orders containing (ZF + K.1 * ZF).}

    F  := BaseField(K);
    ZK := MaximalOrder(K);
    ZF := MaximalOrder(F);
    Kabs := AbsoluteField(K);

    // This is the hugely expensive step.
    if Bound cmpeq 0 then
        hK := ClassNumber(Kabs);
    elif Bound cmpeq "BachBound" then
        hK := ClassNumber(Kabs : Bound := Floor(BachBound(Kabs)/40));
    else
        hK := ClassNumber(Kabs : Bound := Bound);
    end if;

    // Compute the order Oq = ZF[zeta_2s] and its conductor.
    S := Order([K.1]);

    // Cache unit groups.
    UK, mUK := UnitGroup(AbsoluteOrder(ZK));
    UF, mUF := UnitGroup(ZF);

    // Cache the discriminant and conductor.
    Dq := Discriminant(MinimalPolynomial(K.1));
    ff := SquareRoot(ZF !! Discriminant(S)/Discriminant(ZK));

    orders, conductors := OrdersContaining(ZK, S);
    Rdata := [];
    for i in [1..#orders] do
        Oq := orders[i]; dff := conductors[i];
        
        // We need the units.
        UOq, mUOq := UnitGroup(AbsoluteOrder(Oq));

        // We only take orders where Oq has exact torsion unit group of order s.
        // assert #TorsionSubgroup(UOq) eq s;

        // Picard number of the absolute order.
        OqUnitsInK := [mUOq(u) @@ mUK : u in Generators(UOq)];        
        
        // Factors de Artin.
        Fartin := [1 - UnramifiedSquareSymbol(Dq, pp[1])/AbsoluteNorm(pp[1])
                   : pp in Factorization(dff)];

        hOq := hK / #quo<UK | OqUnitsInK> * AbsoluteNorm(dff) * Product(Fartin);
        assert hOq eq #PicardGroup(AbsoluteOrder(Oq));

        // The local unit adjustment. (Hasse unit index)
        UQ  :=  sub<UF | [Norm(ZK ! mUOq(u)) @@ mUF : u in Generators(UOq)]>;
        QOq := #quo<UQ | [2*u : u in Generators(UF)]>;

        Append(~Rdata, rec<OrderTermRecordFormat | Order:=Oq,   
                                                   Conductor:=dff,  
                                                   PicardNumber:=hOq,
                                                   HasseUnitIndex:=QOq>);
    end for;
    
    return Rdata;
end intrinsic;


function PossibleIsotropyOrders(F)
    // Possible stabilizers for elliptic points. (Including -I.)

    S := LCM(CyclotomicQuadraticExtensions(F));
    // S = all prime powers m such that [F(zeta_m):F] = 2
    // Now get all possible m such that [F(zeta_m):F] = 2
    Sdiv := [m : m in Divisors(S) | m ne 1 and Valuation(m,2) ne 1]; // avoid repetition
    Sdiv := [m : m in Sdiv | 
             forall{ f : f in Factorization(CyclotomicPolynomial(m), F)
                     | Degree(f[1]) eq 2} ];
    Sdiv := [IsEven(m) select m else 2*m : m in Sdiv];

    return Sdiv;    
end function;

////////////////////////////////////////////////////////////////////////////////
//
// Main functionality.
//
////////////////////////////////////////////////////////////////////////////////

intrinsic CountEllipticPoints(Gamma::StupidCongruenceSubgroup : Group:="SL") -> Any
{Given a congruence subgroup `Gamma` (level, field, decoration data), return
}
    // The algorithm is based on page 739 of "Quaternion Algebra, Voight".
    // Essentially, we count optimal embeddings of the order generated by the
    // isotropy group of the elliptic point into Gamma, up to conjugation.
    //
    // In the notation of JV, the number of embeddings of S into O, up to conjugation
    // by Gamma is m(S, O; Gamma).

    F  := Field(Gamma);
    ZF := MaximalOrder(F);
    hF := ClassNumber(ZF);
    hFplus := NarrowClassNumber(F);

    dim := Degree(F); // Dimension of Hilbert modular variety.
    assert dim eq 2;

    // TODO: Level data might be important later.
    level := Level(Gamma);
    assert Norm(level) eq 1;

    ellipticCounts := AssociativeArray();
    ellipticCountsByOrder := AssociativeArray();

    isoOrds := PossibleIsotropyOrders(F);
    for rho in isoOrds do
        listOfOrders := OrderTermData(F, Group, rho);
        count := 0;

        for Srec in listOfOrders do
            // Extract Record data
            S  := Srec`Order;
            hS := Srec`PicardNumber;
            QS := Srec`HasseUnitIndex;
            
            localCount := 1; // TODO: Generalize to other levels.
            // localCount := NumberOfAdelicOptimalEmbeddings(ZF, level, Stuple);

            if Group eq "SL" then
                // The case of van der Geer -- PSL_2 acting on upper-half-plane-squared HH^2.
                // The forumla in Proposition 4.2.3 says that the number of elliptic points
                // is
                //
                //     mq^1 = 2^(n-1)/h(R) * Sum(S; h(S)/Q(S) * m(hatS, hatO; hatOtimes)).
                //
                // Where Q(S) is the Hasse Unit Index. We loop over the terms S.

                // NOTE: Factor of 2 in the paper, not in John's book.
                groupCorrectionFactor := 2^(dim-1) / (hF * QS);
                
            elif Group eq "GL+"  then
                // The forumla in Proposition 4.2.3 says that the number of elliptic points
                // is
                //
                //     mq^1 = 2^(n-1)/h^+(R) * Sum(S; h(S) * m(hatS, hatO; hatOtimes)).
                //
                groupCorrectionFactor := 2^(dim-1) / hFplus;

            else
                error "Case for group not implemented. Group := ", Group;
            end if;

            // Record the data into the table.
            ellipticCountsByOrder[S] := hS * groupCorrectionFactor * localCount;
            count +:= hS * groupCorrectionFactor * localCount;
        end for;

        ellipticCounts[ExactQuotient(rho, 2)] := count;        
    end for;

    return ellipticCounts, ellipticCountsByOrder;    
end intrinsic;


////////////////////////////////////////////////////////////////////////////////
//
// Testing.
//
////////////////////////////////////////////////////////////////////////////////

intrinsic _FieldAndGroup(n) -> Any
{}
    F := QuadraticField(n);
    G := CongruenceSubgroup(F);
    return F, G;
end intrinsic;

intrinsic TestEC(n)
{}
    F, G := _FieldAndGroup(n);
    A, B := CountEllipticPoints(G);
    print "Results:";
    print Eltseq(A);
    // print Eltseq(B);
end intrinsic;

intrinsic TestECGL(n)
{}
    F, G := _FieldAndGroup(n);
    A, B := CountEllipticPoints(G : Group:="GL+");
    print "Results:";
    print Eltseq(A);
    // print Eltseq(B);
end intrinsic;

intrinsic ActualCorrectOrders(F::FldNum, rho : Bound := 0) -> Tup
{For a totally real field F, computes and stores the class numbers 
 and associated data for all cyclotomic quadratic extensions of F.}

  ZF := MaximalOrder(F);
  UF, mUF := UnitGroup(ZF);

  // Order of the torsion element.
  s := rho;

  // TODO: Should be able to choose K as sqrt(-u) for some totally positive unit u.
  
  // vprintf Shimura : "Computing class number for %o\n", s;
  fs := Factorization(CyclotomicPolynomial(s), F)[1][1];
  K  := ext<F | fs>;
  ZK := MaximalOrder(K);
  Kabs := AbsoluteField(K);

  // This is the hugely expensive step.
  if Bound cmpeq 0 then
      hK := ClassNumber(Kabs);
  elif Bound cmpeq "BachBound" then
      hK := ClassNumber(Kabs : Bound := Floor(BachBound(Kabs)/40));
  else
      hK := ClassNumber(Kabs : Bound := Bound);
  end if;

  // Compute the order Oq = ZF[zeta_2s] and its conductor.
  Oq := Order([K.1]);
  Dq := Discriminant(MinimalPolynomial(K.1));
  ff := SquareRoot(ZF!!Discriminant(Oq)/Discriminant(ZK));

  UK, mUK := UnitGroup(AbsoluteOrder(ZK));
  wK := #TorsionSubgroup(UK);

  Rdata := [];

  // Loop over orders by their conductor dff.
  for dff in Divisors(ff) do
      
      // if ZK is maximal, we have Cl(O_dff)/Cl(K) = 1.
      if dff eq ideal<ZF | 1> then
          Oq := ZK;
          UOq := UK;
          mUOq := mUK;
          wOq := wK;
          hOq := hK; 

      else
          // Otherwise, use the classic formula to compute the relative class number.
          Oq := OrderWithConductor(ZK, dff);          
          UOq, mUOq := UnitGroup(AbsoluteOrder(Oq));

          // We only take orders where Oq has exact torsion unit group of order s.
          assert #TorsionSubgroup(UOq) eq s;

          // Picard number of the absolute order.
          OqUnitsInK := [mUOq(u) @@ mUK : u in Generators(UOq)];
          
          hOq := hK/#quo<UK | OqUnitsInK> * AbsoluteNorm(dff) *
                    &*[1-UnramifiedSquareSymbol(Dq, pp[1])/AbsoluteNorm(pp[1])
                       : pp in Factorization(dff)];
          
          assert hOq eq #PicardGroup(AbsoluteOrder(Oq));
          // hOq := #PicardGroup(AbsoluteOrder(Oq));
      end if;

      
      // The local unit adjustment. (Hasse unit index)
      UQ  := sub<UF | [Norm(ZK ! mUOq(u)) @@ mUF : u in Generators(UOq)]>;
      QOq := #quo<UQ | [2*u : u in Generators(UF)]>;
      // QOq := HasseUnitIndex(Oq);
      //hQOq := hOq/QOq;


      // dff  -- divisor of conductor of R[i].
      // hOq  -- Class number of the order S.
      // QOq  -- Hasse Unit index of the order S.
      Append(~Rdata, <dff, hOq, Rationals() ! QOq>);
  end for;

  return Rdata;
end intrinsic;

