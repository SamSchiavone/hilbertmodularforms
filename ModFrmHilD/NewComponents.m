/* New implementation */

/* We implement components of HMFs as multivariate polynomials. In the
   background, we think of arithmetic operations as operations modulo an ideal
   (generated by elements q^\nu for \nu outside some "shadow box",
   cf. paper). In the code, we do not work with the ideal. Instead we use
   honest polynomial multiplications then discard unwanted coefficients.

   We provide two implementations: one that uses a multivariate (sparse)
   polynomial ring, and one that uses a tower of (dense) univariate polynomial
   rings. */

declare type NewModFrmHilDEltComp;

declare attributes NewModFrmHilDEltComp: CoefficientRing, // Rng
        Series, // RngMPolElt or RngUPolElt[...]
        ShadowSeries, //same
        Precision, // RngIntElt - the maximum norm of nn for which coefficients are stored
        Space, // ModFrmHilD - the HMF space that this ModFrmHilDEltComp is a component in
        ComponentIdeal; // RngOrdIdl

/* Access to attributes */

intrinsic GradedRing(f :: NewModFrmHilDEltComp) -> ModFrmHilDGRng
{}
    return Parent(f`Space);
end intrinsic;

intrinsic SeriesRing(f :: NewModFrmHilDEltComp) -> Rng
{}
    return Parent(Series(f));
end intrinsic;

intrinsic CoefficientRing(f :: NewModFrmHilDEltComp) -> Rng
{}
    return f`CoefficientRing;
end intrinsic;

intrinsic Series(f :: NewModFrmHilDEltComp) -> RngElt
{}
    if not assigned f`Series and assigned f`ShadowSeries then
        HMFGetSeriesFromShadow(f);
    end if;
    return f`Series;
end intrinsic;

intrinsic ShadowSeries(f :: NewModFrmHilDEltComp) -> RngElt
{}
    if not assigned f`ShadowSeries and assigned f`Series then
        HMFGetShadowFromSeries(f);
    end if;
    return f`ShadowSeries;
end intrinsic;

intrinsic Precision(f :: NewModFrmHilDEltComp) -> RngIntElt
{}
    return f`Precision;
end intrinsic;

intrinsic Space(f :: NewModFrmHilDEltComp) -> ModFrmHilD
{}
    return f`Space;
end intrinsic;

intrinsic ComponentIdeal(f :: NewModFrmHilDEltComp) -> RngOrdIdl
{}
    return f`ComponentIdeal;
end intrinsic;

intrinsic BaseField(f :: NewModFrmHilDEltComp) -> FldNum
{}
    return BaseField(Space(f));
end intrinsic;

/* Access to coefficients */

intrinsic Coefficient(f :: NewModFrmHilDEltComp, nu :: FldNumElt
                      : InFunDomain := false) -> RngElt

{Returns the coefficient of nu in the Fourier series}

    M := GradedRing(f);
    bb := ComponentIdeal(f);
    n := Degree(BaseField(M));

    if not InFunDomain then
        nu, eps := FunDomainRep(M, bb, nu);
    end if;
    b, prec := IsDefined(M`FunDomainRepsPrecisions, nu);

    require b: "Not in fundamental domain";
    require prec le Precision(M): "Not enough precision";

    a :=  HMFSeriesCoefficient(Series(f), M`FunDomainReps[bb][prec][nu]);
    if not InFunDomain then
        uc := UnitCharacters(Space(f))[bb];
        a := a * Evaluate(uc, eps);
    end if;

    return a;
end intrinsic;

// specify two functions of HMFSeriesCoefficient for multivariate and univariate.
// if we choose only one of these implementations, can remove duplicate
intrinsic HMFSeriesCoefficient(f :: RngUPolElt, exp :: SeqEnum[RngIntElt]) -> RngElt

{Internal function: get coefficient of f with the given exponent}

    n := #exp;
    g := f;
    for i in [0..(n-1)] do
        g := Coefficient(g, exp[n - i]);
    end for;
    return g;
end intrinsic;

intrinsic HMFSeriesCoefficient(f :: RngMPolElt, exp :: SeqEnum[RngIntElt]) -> RngElt

{Internal function: get coefficient of f with the given exponent}

    P := Parent(f);
    mon := Monomial(P, exp);
    return MonomialCoefficient(f, mon);
end intrinsic;

/* Converting between series and shadow series */

intrinsic HMFGetSeriesFromShadow(f :: NewModFrmHilDEltComp)

{Internal function: compute f`Series from f`ShadowSeries}

    M := GradedRing(f);
    bb := ComponentIdeal(f);

    exponents := [];
    for prec in M`PrecisionsByComponent[bb] do
        if prec le Precision(f) then
            for nu->exp in M`FunDomainReps[bb][prec] do
                Append(~exps, exp);
            end for;
        end if;
    end for;

    f`Series := HMFSeriesSubset(f`ShadowSeries, exps);
end intrinsic;

intrinsic HMFSeriesSubset(f :: RngMPolElt, exps :: SeqEnum) -> RngMPolElt

{Internal function: extract only the specified exponents from the series}

    R := Parent(f);
    mons := [Monomial(R, e): e in exps];
    coeffs := [MonomialCoefficient(f, mon): mon in mons];
    return Polynomial(coeffs, mons);
end intrinsic;

intrinsic HMFSeriesSubset(f :: RngUPolElt, exps :: SeqEnum) -> RngUPolElt

{Internal function: extract only the specified exponents from the series}

    if #exps eq 0 then
        return Parent(f) ! 0;
    end if;

    n := #exps[1];
    P := Parent(f);
    last_entries := [e[n]: e in exps];
    new_coefs := [0: i in [0..Max(last_entries)]];

    if n eq 1 then
        for e in exps do
            new_coefs[e[1]] := Coefficient(f, e[1]);
        end for;
    else
        last_entries := SetToSequence(SequenceToSet(last_entries));
        for d in last_entries do
            rec_exps := [e[1..(n-1)]: e in exps | e[n] eq d];
            new_coefs[d] := HMFSeriesSubset(Coefficient(f, d), rec_exps);
        end for;
    end if;

    return P ! new_coefs;
end intrinsic;

intrinsic HMFGetShadowFromSeries(f :: NewModFrmHilDEltComp)

{Internal function: compute f`ShadowSeries from f`Series}

    M := GradedRing(f);
    bb := ComponentIdeal(f);
    uc := UnitCharacters(Space(f))[bb];

    exps := [];
    coefs := [];
    for prec in M`PrecisionsByComponent[bb] do
        if prec le Precision(f) do
            for nuprime->exp_nuprime in M`FunDomainReps[bb][prec] do
                a := Coefficient(f, nuprime: IsFunDomain := true);
                for eps->exp_nu in M`NewShadows[bb][nu] do
                    Append(~coefs, a * Evaluate(uc, eps));
                    Append(~exps, exp_nu);
                end for;
            end for;
        end if;
    end for;

    f`ShadowSeries := HMFConstructSeries(SeriesRing(f), exps, coefs);
end intrinsic;

intrinsic HMFConstructSeries(R :: RngMPol, exps :: SeqEnum, coefs :: SeqEnum[RngElt]
    ) -> RngMPolElt

{Internal function: construct the Fourier expansion with the specified
coefficients as an element of R}

    mons := [Monomial(R, e): e in exps];
    return Polynomial(coefs, mons);
end intrinsic;

intrinsic HMFConstructSeries(R :: RngUPol, exps :: SeqEnum, coefs :: SeqEnum[RngElt]
    ) -> RngUPolElt

{Internal function: construct the Fourier expansion with the specified
coefficients as an element of R}

    if #exps eq 0 then
        return R!0;
    end if;

    n := #exps[1];
    last_entries := [e[n]: e in exps];
    pol_coefs := [0: i in [0..Max(last_entries)]];
    if n eq 1 then
        for i in [1..#exps] do
            pol_coefs[exps[i][1]] := coefs[i];
        end for;
    else
        last_entries := SetToSequence(SequenceToSet(last_entries));
        for d in last_entries do
            rec_exps := [];
            rec_coefs := [];
            for i in [1..#exps] do
                e := exps[i];
                if e[n] eq d then
                    Append(~rec_exps, e[1..(n-1)]);
                    Append(~rec_coefs, coefs[i]);
                end if;
            end for;
            pol_coefs[d] := HMFConstructSeries(BaseRing(R), rec_exps, rec_coefs);
        end for;
    end if;

    return R ! pol_coefs;
end intrinsic;

/* Pruning */

intrinsic HMFPruneSeries(f :: NewModFrmHilDEltComp)

{Internal function: replace f`Series by pruned version}

    exps := [];
    precs := [p: p in M`PrecisionsByComponent[bb] | p le Precision(f)];
    for p in precs do
        exps := exps cat Values(M`FunDomainReps[bb][p]);
    end for;
    f`Series := HMFSeriesSubset(f`Series, exps);

end intrinsic;

intrinsic HMFPruneShadowSeries(f :: NewModFrmHilDEltCom)

{Internal function: replace f`ShadowSeries by pruned version}

    exps := [];
    precs := [p: p in M`PrecisionsByComponent[bb] | p le Precision(f)];
    for p in precs do
        for nu->exp_nu in M`FunDomainReps[bb][p] do
            exps := exps cat Values(M`NewShadows[bb][nu])
        end for;
    end for;
    f`ShadowSeries := HMFSeriesSubset(f`ShadowSeries, exps);

end intrinsic;

/* Constructors */

intrinsic HMFComponent(Mk :: ModFrmHilD, bb :: RngOrdIdl, f :: RngElt, prec :: RngIntElt :
                       Shadow := false, Prune := true
    ) -> NewModFrmHilDEltComp

{Internal function: constructs the HMF component whose Fourier series is
specified by the polynomial f at the given precision. Parent(f) should either
be a multivariate polynomial ring or a tower of univariate polynomial rings.}

    n := Degree(BaseField(Mk));

    if Type(f) eq RngMPolElt then
        R := BaseRing(f);
    elif Type(f) eq RngUPolElt then
        R := Parent(f);
        for i in [1..n] do
            R := BaseRing(R);
        end for;
    else
        error "Unsupported type for Fourier expansions: ", Type(f);
    end if;

    g := New(NewModFrmHilDEltComp);
    g`Space := Mk;
    g`ComponentIdeal := bb;
    g`CoefficientRing := R;
    g`Precision := prec;
    if Shadow then
        g`ShadowSeries := f;
    else
        g`Series := f;
    end if;

    if Prune then
        if Shadow then
            HMFPruneShadowSeries(g);
        else
            HMFPruneSeries(g);
        end if;
    end if;

end intrinsic;

intrinsic HMFComponent(Mk :: ModFrmHilD, bb :: RngOrdIdl, coeffs :: Assoc, prec :: RngIntElt
                       : Multivariate := true, CoefficientRing := DefaultCoeffeicientRing(Mk),
                         Precision := Precision(Parent(M))
    ) -> NewModFrmHilDEltComp

{Constructs the HMF component to precision prec whose Fourier coefficients are
specified by the given array indexed by nus in the fundamental domain.

By default, we assume that the coefficient ring is the default coefficient ring
of Mk, and that coefficients are specified up to the default precision of the
ambient graded ring. The user may specify another coefficient ring or a lower
precision instead.}

    M := Parent(Mk);
    n := Degree(BaseField(Mk));

    // Gather exponents and coefficients
    precs := [p: p in M`PrecisionsByComponent[bb] | p le Precision];
    exps := [];
    coefs := [];
    for p in precs do
        for nu->exp in M`FunDomainReps[bb][p] do
            b, coef := IsDefined(coeffs, nu);
            require b: "Coefficient not found for index: ", nu;
            Append(~exps, exp);
            Append(~coefs, coef);
        end for;
    end for;

    // Construct series ring
    if Multivariate then
        R := PolynomialRing(CoefficientRing, n);
    else
        R := CoefficientRing;
        for i in [1..n] do
            R := PolynomialRing(R);
        end for;
    end if;

    f := HMFConstructSeries(R, exps, coefs);
    return HMFComponent(Mk, bb, f: Shadow := false, Prune := false, Precision := Precision);

end intrinsic;

/* Base change */

intrinsic ChangeRing(f :: ModFrmHilDEltComp, R :: Rng) -> ModFrmHilDEltComp

{Constructs the HMF component that is identical to f, except that its
coefficient ring is extended to R.}

    Mk := Space(f);
    n := Degree(BaseField(Mk));
    bb := ComponentIdeal(f);
    ser := ShadowSeries(f);

    // Construct larger series ring
    if Type(ShadowSeries(f)) eq RngMPolElt then
        S := ChangeRing(Parent(ser), R);
        ser := S ! ser;
    else
        S := R;
        for i in [1..n] do
            S := PolynomialRing(S);
        end for;
        ser := S ! ser;
    end if;

    return HMFComponent(Mk, bb, ser, prec : Shadow := true, Prune := false);
end intrinsic;

/* Arithmetic operations */

intrinsic '+'(f :: ModFrmHilDEltComp, g :: ModFrmHilDEltComp) -> ModFrmHilDEltComp
{}
    require Space(f) eq Space(g) : "Cannot add HMF components from different spaces";
    require ComponentIdeal(f) eq ComponentIdeal(g): "Cannot add HMF components attached to different narrow class group representatives";

    bb := ComponentIdeal(f);
    prec := Min(Precision(f), Precision(g));
    series := Series(f) + Series(g);
    exps := FunDomainExpsUpToNorm(GradedRing(f), bb, prec);
    series := HMFSeriesSubset(series, exps);
    return HMFComponent(Space(f), bb, f : coeff_ring := CoefficientRing(f), prec := prec);
end intrinsic;

intrinsic '*'(c :: RngElt, f :: ModFrmHilDEltComp) -> ModFrmHilDEltComp
{}
    R := CoefficientRing(f);
    b, c_K := IsStrongCoercible(K, c);

    require b : "We cannot scale an HMF by a scalar not coercible into its coefficient field";

    return HMFComponent(Space(f), ComponentIdeal(f), c_K * Series(f)
                        : coeff_ring := CoefficientRing(f), prec := Precision(f));
end intrinsic;

intrinsic '-'(f :: ModFrmHilDEltComp, g :: ModFrmHilDEltComp) -> ModFrmHilDEltComp
{}
    R := CoefficientRing(f);
    return f + R!(-1) * g;
end intrinsic;

