/* New implementation */

/* We implement components of HMFs as multivariate polynomials. In the
   background, we think of arithmetic operations as operations modulo an ideal
   (generated by elements q^\nu for \nu outside some "shadow box",
   cf. paper). In the code, we do not work with the ideal. Instead we use
   honest polynomial multiplications then discard unwanted coefficients.

   We provide two implementations: one that uses a multivariate (sparse)
   polynomial ring, and one that uses a tower of (dense) univariate polynomial
   rings. */

declare type NewModFrmHilDEltComp;

declare attributes NewModFrmHilDEltComp: Series, // RngMPolElt or RngUPolElt[...]
        ShadowSeries, //same
        Precision, // RngIntElt - the maximum norm of nn for which coefficients are stored
        Space, // ModFrmHilD - the HMF space that this ModFrmHilDEltComp is a component in
        ComponentIdeal; // RngOrdIdl

/* Access to attributes */

intrinsic Series(f :: NewModFrmHilDEltComp) -> RngElt
{}
    if not assigned f`Series then
        if assigned f`ShadowSeries then
            f`Series := HMFSeriesFromShadow(f`ShadowSeries);
        else
            error "HMF series not assigned";
        end if;
    end if;

    return f`Series;
end intrinsic;

intrinsic ShadowSeries(f :: NewModFrmHilDEltComp) -> RngElt
{}
    if not assigned f`ShadowSeries then
        if assigned f`Series then
            f`ShadowSeries := HMFShadowFromSeries(f`Series);
        else
            error "HMF series not assigned";
        end if;
    end if;

    return f`ShadowSeries;
end intrinsic;

intrinsic Precision(f :: NewModFrmHilDEltComp) -> RngIntElt
{}
    return f`Precision;
end intrinsic;

intrinsic Space(f :: NewModFrmHilDEltComp) -> ModFrmHilD
{}
    return f`Space;
end intrinsic;

intrinsic ComponentIdeal(f :: NewModFrmHilDEltComp) -> RngOrdIdl
{}
    return f`ComponentIdeal;
end intrinsic;

intrinsic IsMultivariate(f :: NewModFrmHilDEltComp) -> BoolElt
{}
    return Type(f`Series) eq RngMPolElt;
end intrinsic;

intrinsic BaseField(f :: NewModFrmHilDEltComp) -> FldNum
{}
    return BaseField(Space(f));
end intrinsic;

/* Constructors */

intrinsic HMFComponent(M :: ModFrmHilD, b :: RngOrdIdl, f :: RngElt
                       : multivariate := true,
                         coeff_ring := DefaultCoefficientRing(Mk),
                         prec := Parent(Mk)`Precision,
                         shadow := false
    ) -> NewModFrmHilDEltComp

{Constructs a ModFrmHilDEltComp whose associated polynomial is f, either a
multivariate polynomial or an element in a tower of univariate polynomials. By
default, we assume that f is multivariate, that its exactly correspond to the
Series field of the result up to the ambient precision of the graded ring of
HMFs, and we coerce the coefficients of f to the DefaultCoefficientRing of Mk.

If 'multivariate' is set to false, assume that f is a univariate polynomial
instead. If 'shadow' is set to true, assume that f contains the ShadowSeries
instead. If f is only known to a lower precision, the user should input the
relevant 'prec' parameter. The user may input a different coefficient ring as
coeff_ring. If f contains too many coefficients, the user should call HMFPrune
afterwards.}

    n := Degree(BaseField(Mk));
    comp := New(NewModFrmHilDEltComp);
    comp`Space := Mk;
    comp`Precision := prec;
    comp`ComponentIdeal := b;

    if multivariate then
        pol_ring := PolynomialRing(coeff_ring, n);
        f := pol_ring ! f; /*todo: use StrongCoerce*/
    else
        pol_ring := coeff_ring;
        for i in [1..n] do
            pol_ring := PolynomialRing(pol_ring);
        end for;
        f := pol_ring ! f; /*todo: use StrongCoerce*/
    end if;

    if shadow then
        comp`ShadowSeries := f;
    else
        comp`Series := f;
    end if;

    return comp;
end intrinsic;

/* Pruning */

intrinsic HMFCompPrune(f :: NewModFrmHilDEltComp : shadow := false)

{Prune the Series of f in-place. If shadow is set to true, prune the shadow
series instead}

    if IsMultivariate(f) then
        
    else

    end if;

end intrinsic;


/* Coefficient access */

intrinsic CoordinatesInIndexBasis(f :: ModFrmHilDEltComp, nu :: FldElt) -> RngIntElt

{Return a tuple of integers (e_1,...,e_n) such that q^nu corresponds to the
monomial x_1^e_1 ... x_n^e_n}

    row = Matrix(Rationals(), Eltseq(nu));
    return Eltseq(row * NuToExpMatrix(f));

end intrinsic;

intrinsic Coefficient(f :: ModFrmHilDEltComp, seq :: SeqEnum[RngIntElt]) -> FldElt

{Return the coefficient of f attached to the given sequence of integers}

    if IsMultivariate(f) then
        m := Monomial(Parent(f), seq);
        return MonomialCoefficient(f, m);
    else
        n := Degree(BaseField(f));
        g := f;
        for i in [1..n] do
            g := Coefficient(g, seq[n + 1 - i]);
        end for;
        return g;
    end if;
end intrinsic;

intrinsic Coefficient(f :: ModFrmHilDEltComp, nu :: FldElt) -> FldElt

{Return the coefficient of f attached to the field element nu}

    seq := CoordinatesInIndexBasis(f, nu);
    return Coefficient(f, seq);
end intrinsic;
