///// Shintani Algorithms + Enumerations of Totally positive elements in ideals /////////

intrinsic Slope(alpha::RngOrdElt) -> FldReElt
  { Input:  alpha, an element of ZF for F a totally real quadratic number field
    Output: The "slope" defined by alpha: sigma_2(alpha)/sigma_1(alpha) where 
    sigma_i is the ith embedding of F}
  OK := Parent(alpha);
  K := NumberField(OK);
  places := InfinitePlaces(K);
  return Evaluate(alpha, places[2]) / Evaluate(alpha, places[1]);
end intrinsic;

// Rearranges the basis for an ideal so that the second basis vector has trace 0
intrinsic TraceBasis(bb::RngOrdFracIdl) -> SeqEnum
  {Given a fractional ideal bb, returns a basis (a,b) in Smith normal form where Trace(a) = n and Trace(b) = 0}
  // Preliminaries
  B := Basis(bb);
  ZF := Parent(B[2]);
  // Sort Basis elemements according to the size of their trace
  BTr := [Trace(b) : b in B];
  ParallelSort(~BTr,~B);
  // Change of basis
  Tr := Matrix([[Trace(B[i]) : i in [1..#B]]]);
  _,_,Q := SmithForm(Tr);
  require Determinant(Q) eq 1: "Not a change of basis";
  ChangeofBasisMatrix := ChangeRing(Q,ZF);
  NewBasis := Eltseq(Vector(B)*ChangeofBasisMatrix);
  return NewBasis;
end intrinsic;

///////////////////////////////////////////////////
//                                               //
//   Enumeration of Totally Positive elements    //
//                                               //
///////////////////////////////////////////////////

/*
// Totally Positive Elements in an Ideal 
   From a basis {a,b} for the ideal bb where 
     Tr(a) = n and Tr(b) = 0. 
   Elements in ideal will look like xa + yb where x,y in ZZ 
   and have embedding xa_1 + yb_1 and xa_2 + yb_2.  
   All totally positive elements of given trace t will satisfy 
   1)    t = Tr(xa+yb)    <=>   t = xn    
   2)    xa+yb totally positive       <=>   y > -x*a_1/b_1   and  y > -x*a_2/b_2  
   Eq 1) determines the value for x,
     and Eq 2) allows us to loop over values of y 
*/
intrinsic PositiveElementsOfTrace(bb::RngOrdFracIdl, t::RngIntElt) -> SeqEnum[RngOrdFracIdl]
  {Given bb a fractional ideal and t a nonnegative integer, 
   returns the totally positive elements of bb with trace t.}
  basis := TraceBasis(bb);
  places := InfinitePlaces(NumberField(Parent(basis[1])));
  smallestTrace := Trace(basis[1]);
  T := [];
  if t mod smallestTrace eq 0 then
    x := t div smallestTrace;
    a_1 := Evaluate(basis[1],places[1]); 
    b_1 := Evaluate(basis[2],places[1]);
    a_2 := Evaluate(basis[1],places[2]); 
    b_2 := Evaluate(basis[2],places[2]);
    lower_bnd := Ceiling(Min(-x*a_1/b_1,-x*a_2/b_2));
    upper_bnd := Floor(Max(-x*a_1/b_1,-x*a_2/b_2));
    for y in [lower_bnd .. upper_bnd] do
      Append(~T, x*basis[1]+y*basis[2]);
    end for;
  end if;
  return T;
end intrinsic;

intrinsic ElementsInABox(M::ModFrmHilDGRng, bb::RngOrdFracIdl, 
                         XLBound::Any, YLBound::Any, XUBound::Any, YUBound::Any) -> SeqEnum
  {Enumerates all elements c in bb with 0 < c_1 < Xbound and  0 < c_2 < Ybound}    

  for bnd in [XUBound, YUBound, XLBound, YLBound] do
    require IsCoercible(Type(bnd),FldReElt) : "Bounds must be coercible to real numbers";
  end for;
  basis := TraceBasis(bb);
  F := BaseField(M);
  ZF := Integers(M);
  places := Places(M);

  // Precomputationss 
  a_1 := Evaluate(basis[1],places[1]); 
  b_1 := Evaluate(basis[2],places[1]);
  a_2 := Evaluate(basis[1],places[2]); 
  b_2 := Evaluate(basis[2],places[2]);

  // List of all Elements
  T := [];
  trLBound := Ceiling(XLBound+YLBound);
  trUBound := Floor(XUBound+YUBound);
  for x in [trLBound..trUBound] do 
    lBound := Ceiling(Max((XLBound-x*a_1)/b_1,(YUBound-x*a_2)/b_2));
    uBound := Floor(Min((XUBound-x*a_1)/b_1,(YLBound-x*a_2)/b_2));
    for y in [lBound..uBound] do
      Append(~T, x*basis[1]+y*basis[2]);
    end for;
  end for;

  return T;
end intrinsic;


///////////////////////////////////////////////////
//                                               //
//          Shintani Domain algorithms           //
//                                               //
///////////////////////////////////////////////////

// Helper Functions
// Returns the slopes of the upper and lower walls for the Shintani Domain
intrinsic ShintaniWalls(ZF::RngOrd) -> Any
  {returns lower and upper walls of the Shintani domain}
  require Degree(ZF) eq 2: "only implemented for quadratic fields";
  D := Discriminant(ZF);
  F := NumberField(ZF);
  places := InfinitePlaces(F);
  if assigned F`FundamentalUnit then
    eps := F`FundamentalUnit;
  else
    eps := FundamentalUnit(F);
    if Norm(eps) eq -1 then
      // In this case CK = CK^+ so the totally positive units are squares 
      // i.e. the subgroup generated by eps^2
      eps := eps^2;
    else // Nm(eps) = 1
      if not IsTotallyPositive(eps) then
        // In this case CK not equal to CK^+ so there are no units of mixed signs. 
        // If the fundamental unit is not totally positive we multiply by -1.
        eps := -1*eps;
      end if;
    end if;
    eps1 := Evaluate(eps, places[1]);
    if eps1 gt 1 then
      // eps1*eps2 = Nm(eps) = 1
      eps := 1/eps;
    end if; 
    F`FundamentalUnit := eps;
  end if;
  eps1 := Evaluate(eps, places[1]);
  eps2 := Evaluate(eps, places[2]);

  return Sqrt(eps1/eps2), Sqrt(eps2/eps1);
end intrinsic;


// Elements of the Shintani domain with trace t
/* Idea: We compute a basis a,b for the ideal bb where Tr(a) = n > 0 and Tr(b) = 0. 
   Elements in ideal will look like xa+yb where x,y in ZZ and have embedding 
      xa_1 + yb_1 and xa_2 + yb_2. 
   All totally positive elements of given trace t will satisfy
   1) t = Tr(xa+yb)    <=>   t = xn
   2) C_1 < (xa_1+yb_1)/(xa_2+yb_2) < C_2    <=>   
      (C_1*x*a_2-x*a_1)/(b_1-C_1*b_2) < y < (C_2*x*a_2-x*a_1)/(b_1-C_2*b_2)
   where C1 and C2 are the slope bounds on the Shintani domain. 
   Eq 1) determines the value for x while 
   Eq 2) allows us to loop over values of y. 
*/
intrinsic ShintaniRepsOfTrace(bb::RngOrdFracIdl, t::RngIntElt) -> SeqEnum[RngOrdFracIdl]
  {Given bb a fractional ideal, t a trace, returns the totally positive elements 
   of bb in the balanced Shintani cone with trace t.}  

  basis := TraceBasis(bb);
  F := NumberField(Parent(basis[1]));
  ZF := Integers(F);
  places := InfinitePlaces(F);

  if t eq 0 then
    return [ZF!0];
  else  
    smallestTrace := Trace(basis[1]);
    T := [];
    if t mod smallestTrace eq 0 then
      x := t div SmallestTrace;
      C1,C2 := ShintaniWalls(ZF);
      a1 := Evaluate(basis[1],places[1]); 
      b1 := Evaluate(basis[2],places[1]);
      a2 := Evaluate(basis[1],places[2]); 
      b2 := Evaluate(basis[2],places[2]);

      lowerbnd := (C2*x*a2-x*a1)/(b1-C2*b2); 
      upperbnd := (C1*x*a2-x*a1)/(b1-C1*b2); 
      // Magma has some extreme problems with .999999999 /= 1. 
      // That is why this is defined in a terrible manner. 
      // It removes points that lie on the upper wall.
      prec := Precision(lowerbnd);
      if Abs(Round(lowerbnd) - lowerbnd) lt 10^(-prec/2) then 
        lowerbnd := Round(lowerbnd); 
      else 
        lowerbnd := Ceiling(lowerbnd); 
      end if;
      if Abs(Round(upperbnd) - upperbnd) lt 10^(-prec/2) then 
        upperbnd := Round(upperbnd)-1; 
      else 
        upperbnd := Floor(upperbnd); 
      end if;
      for y in [lowerbnd .. upperbnd] do
        Append(~T, x*basis[1]+y*basis[2]);
      end for;
    end if;
    return T;
  end if;
end intrinsic;


///////////////////////////////////////////////////
//                                               //
//          Shintani Reduction Algorithms        //
//                                               //
///////////////////////////////////////////////////


// Shintani reduction algorithm
// Use this function: it first does a lookup to see if already in the
// Shintani cone, else it seeks to minimize the trace
intrinsic ReduceShintani(nu::RngOrdElt, bb::RngOrdFracIdl, M::ModFrmHilDGRng) -> SeqEnum
  {Reduce the element nu in component labelled bb.}
  assert Parent(nu) eq Integers(M);
  shintani_reps := ShintaniReps(M);
  if nu in Keys(shintani_reps[bb]) then
    return shintani_reps[bb][nu];
  else
    return ReduceShintaniMinimizeTrace(nu);
  end if;
end intrinsic;

// Shintani reduction algorithm (workhorse)
intrinsic ReduceShintaniMinimizeTrace(nu::RngOrdElt) -> Any
  {Reduce the element nu to the Shintani domain.}

  if nu eq 0 then
    return Parent(nu)!0, 1;
  end if;

  // Preliminaries
  ZF := Parent(nu);
  F := NumberField(ZF);
  // Asserts
  require IsTotallyPositive(nu): "nu must be totally positive";
  require Degree(F) eq 2: "Shintani domains only implemented for quadratic fields";

  // Fundamental unit
  U, mU := UnitGroup(ZF);
  eps := mU(U.2); // Assuming quadratic field then this should be the fundamental unit.
  places := InfinitePlaces(F);
  // Replace with generator for totally positive units
  sign_eps := Set(Signature(F!eps)); // Signs of fundamental unit: {1,-1}, {-1}, or {1}.
  if sign_eps eq {-1} then // Case 1: Sign(eps) = [-1,-1] so we replace with -eps.
    eps := -eps;
  elif sign_eps eq {1,-1} then // Case 2: Sign(eps) = [-1,1] so we replace with eps^2.
    eps := eps^2;
  else // Case 3: Sign(eps) = [1,1] so we leave it eps.
    eps := eps;
  end if;

  eps_RR := [Evaluate(eps,pl) : pl in Places];
  slope_eps := Slope(eps);
  slope_nu := Slope(nu);
  // TODO: do we know calculus?
  // r := -Floor( RealField(100)!(Log(slope_nu)/Log(slope_eps)) ); // old formula
  /* r := Integers()!((1/2)*Round(Log(RealField(100)!slope_nu)/Log(RealField(100)!eps_RR[1]))); */
  RR := RealField(100);
  ratio := RR!(1/2)*Log(RR!slope_nu)/Log(RR!eps_RR[1]);
  ratio_ceiling := Ceiling(ratio);
  ratio_floor := Floor(ratio);
  nu_ceiling := eps^ratio_ceiling*nu;
  nu_floor := eps^ratio_floor*nu;
  slope_nu_ceiling := Slope(nu_ceiling);
  slope_nu_floor := Slope(nu_floor);
  slopes := [slope_nu_floor, slope_nu_ceiling];
  nus := [nu_floor, nu_ceiling];
  epses := [eps^ratio_floor, eps^ratio_ceiling];
  ParallelSort(~slopes, ~nus);
  ParallelSort(~slopes, ~epses);
  if IsShintaniReduced(nus[1]) then
    return nus[1], epses[1];
  else
    assert IsShintaniReduced(nus[2]);
    return nus[2], epses[2];
  end if;
end intrinsic;


// Test if an element is Shintani reduced 
intrinsic IsShintaniReduced(nu::RngOrdElt) -> BoolElt
  {}
  // zero is Shintani Reduced
  if nu eq Parent(nu)!0 then
    return true;
  end if;
  // wall1<wall2
  wall1, wall2 := ShintaniWalls(Parent(nu));
  slope := Slope(nu);
  prec := Precision(Parent(slope));
  // walls with fuzz
  if (wall1-10^(-prec/2) le slope) and (slope le wall2+10^(-prec/2)) then
    return true;
  else
    return false;
  end if;
end intrinsic;

/////////////////////// Totally positive associate /////////////////

intrinsic TotallyPositiveAssociate(M::ModFrmHilDGRng, gen::RngOrdElt) -> RngOrdElt
  {Finds a totally positive associate to the given element}
  U := UnitGroup(M);
  mU := UnitGroupMap(M);
  F := BaseField(M);
  ZF := Integers(M);
  UnitGenerators := [F!(mU(u)) : u in Generators(U)];
  UnitSignatures := [Signature(u) : u in UnitGenerators];
  
  // function 1 => 0 and -1 => 1;
  h := function(x); 
    if x eq 1 then return 0; else return 1; end if;
  end function;

  GenSignature := [ h(i) : i in Signature(F!gen)];
  // if not totally positive
  if exists{i : i in GenSignature | i eq 1} then 
    UnitSignatures := [[h(i) : i in j] : j in UnitSignatures];
    F2 := GF(2);
    Mat := Matrix(F2,UnitSignatures);
    V := Vector(F2,GenSignature);
    X := Solution(Mat,V);
    UNIT := &*[UnitGenerators[i] : i in [1..#Generators(U)] | X[i] ne 0 ];
    gen := ZF!(gen*UNIT);
  end if;
  return gen;
end intrinsic;

intrinsic Signature(a::RngOrdElt) -> SeqEnum
  {}
  R := Parent(a);
  return Signature(FieldOfFractions(R)!a);
end intrinsic;

intrinsic TotallyPositiveUnits(R::Rng) -> SeqEnum
  {}
  U, mp := UnitGroup(R);
  // Stupid function, the isomorphism mu_2 -> ZZ/2*ZZ
  hiota := function(u);
    if u eq -1 then
      return 1;
    else
      return 0;
    end if;
  end function;

  F := NumberField(R);
  UZd := AbelianGroup([2 : i in [1..Degree(F)]]);
  phi := hom<U -> UZd | [[hiota(Sign(Evaluate(mp(U.i), v))) : v in RealPlaces(F)] : i in [1..#Generators(U)]]>;
  K := Kernel(phi);
  return K, mp;
end intrinsic;

/////////////////////// Conversion Functions /////////////////////


// Conversion : Shintani elements < = > Ideals
// Converts pairs (bb,nu) <-> (bb,n) based on the set of representatives bb for Cl^+(F)
intrinsic IdealToShintaniRepresentative(M::ModFrmHilDGRng, bb::RngOrdIdl, nn::RngOrdIdl) -> ModFrmHilDElt
  {Takes a representative [bb] in Cl^+(F) and an integral ideal n in ZF with [n] = [bb^(-1)] and returns Shintani representative (nu) = n*bb}
  F := BaseField(M);
  ZF := Integers(M);
  dd := Different(ZF);
  bbp := bb*(dd)^-1;
  mp := NarrowClassGroupMap(M);
  require IsIdentity((nn*bbp)@@mp): "The ideals nn and bb must be inverses in CL+(F)";
  bool, gen := IsPrincipal(nn*bbp);
  // This is hardcoded for quadratic Fields.
  gen := TotallyPositiveAssociate(M,gen);
  ShintaniGenerator := ReduceShintaniMinimizeTrace(gen);
  return ShintaniGenerator;
end intrinsic;

// Conversion : Shintani elements < = > Ideals
// Converts nu <-> n, without needing bb as input 
intrinsic IdealToShintaniRepresentative(M::ModFrmHilDGRng, nn::RngOrdIdl) -> RngOrdElt
  {Takes a representative [bb] in Cl^+(F) and an integral ideal n in ZF with 
   [n] = [bb^(-1)] and returns Shintani representative (nu) = n*bb}
  F := BaseField(M);
  mp := NarrowClassGroupMap(M);
  bbp := mp(-(nn @@ mp)); // bb' is inverse of nn in narrow class group
  bool, gen := IsPrincipal(nn*bb);
  assert bool;
  // This is hardcoded for quadratic Fields.
  gen := TotallyPositiveAssociate(M,gen);
  return ReduceShintaniMinimizeTrace(gen);
end intrinsic;

// Converts nus to nns
intrinsic ShintaniRepresentativeToIdeal(M::ModFrmHilDGRng, bb::RngOrdFracIdl, nu::RngOrdElt) -> RngOrdIdl
  {Takes a representative [bb^(-1)] in Cl^+(F) and a nu in bb_+ and returns the 
   integral ideal n = bb^(-1)*(nu) in ZF}
  if not IsDefined(M`ShintaniRepsIdeal[bb], nu) then
    R := M`Integers;
    dd := Different(R);
    bbp := bb*(dd^-1);
    M`ShintaniRepsIdeal[bb][nu] := NicefyIdeal(nu*bbp^(-1));
  end if;
  return M`ShintaniRepsIdeal[bb][nu];
end intrinsic;

intrinsic PopulateShintaniRepsIdeal(M::ModFrmHilDGRng, bb::RngOrdFracIdl, nus::SetEnum[RngOrdElt])
 {populates ShintaniRepsIdeal[bb][nu] for nu in nus}
  bbinv := bb^(-1);
  for nu in nus diff Keys(M`ShintaniRepsIdeal[bb]) do
    // See ShintaniRepresentativeToIdeal
    M`ShintaniRepsIdeal[bb][nu] := NicefyIdeal(nu*bbinv);
  end for;
end intrinsic;
